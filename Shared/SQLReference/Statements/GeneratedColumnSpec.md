[Open topic with navigation](../../../index.html#Shared/SQLReference/Statements/GeneratedColumnSpec.html)

<a href="" id="Statements.GeneratedColumnSpec"></a>[]()generated-column-spec
============================================================================

A generated column is one whose value is defined by an expression, typically involving values from other columns in the same table. The value of a generated column is automatically updated whenever there's a change in the value of any column upon which the expression depends.

``` FcnSyntax
[ GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY 
[ ( START WITH IntegerConstant 
[ ,INCREMENT BY IntegerConstant] ) ]  ]  ]
```

{ALWAYS | BY DEFAULT} AS IDENTITY

A table can have at most one identity column. See the [Identity Column Attributes](#IdentityAttributes) section below for more information about identity columns.Splice Machine supports two kinds of identity columns:

<span class="CodeFont">GENERATED ALWAYS</span>

An identity column that is <span class="CodeFont">GENERATED ALWAYS</span> will increment the default value on every insertion and will store the incremented value into the column. Unlike other defaults, you cannot insert a value directly into or update an identity column that is <span class="CodeFont">GENERATED ALWAYS</span>. Instead, either specify the <span class="CodeFont">DEFAULT</span> keyword when inserting into the identity column, or leave the identity column out of the insertion column list altogether. For example:

``` Example
create table greetings
  (i int generated always as identity, ch char(50));
insert into greetings values (DEFAULT, 'hello');
insert into greetings(ch) values ('bonjour');
```

Automatically generated values in a <span class="CodeFont">GENERATED ALWAYS</span> identity column are unique. Creating an identity column does not create an index on the column.

<span class="CodeFont">GENERATED BY DEFAULT</span>

An identity column that is <span class="CodeFont">GENERATED BY DEFAULT</span> will only increment and use the default value on insertions when no explicit value is given. Unlike <span class="CodeFont">GENERATED ALWAYS</span> columns, you can specify a particular value in an insertion statement to be used instead of the generated default value.

To use the generated default, either specify the <span class="CodeFont">DEFAULT</span> keyword when inserting into the identity column, or just leave the identity column out of the insertion column list. To specify a value, included it in the insertion statement. For example:

``` Example
create table greetings
(i int generated by default as identity, ch char(50));
       -- specify value "1":
insert into greetings values (1, 'hi');
       -- use generated default
insert into greetings values (DEFAULT, 'salut');
       -- use generated default
insert into greetings(ch) values ('bonjour'); 
```

Note that unlike a <span class="CodeFont">GENERATED ALWAYS</span> column, a <span class="CodeFont">GENERATED BY DEFAULT</span> column does not guarantee uniqueness. Thus, in the above example, the hi and salut rows will both have an identity value of "1", because the generated column starts at <span class="CodeFont">1</span> and the user-specified value was also <span class="CodeFont">1</span>. You can prevent duplication by specifying a <span class="CodeFont">START WITH</span> value, and using a primary key or unique constraint on the identity column

START WITH IntegerConstant

The first identity value that Splice Machine should assign.

INCREMENT BY IntegerConstant

The amount by which to increment the identity value each time one is assigned.

<a href="" id="IdentityAttributes"></a>Identity Column Attributes

A table can have at most one identity column.

For <span class="CodeFont">SMALLINT</span>, <span class="CodeFont">INT</span>, and <span class="CodeFont">BIGINT</span> columns with identity attributes, Splice Machine automatically assigns increasing integer values to the column. Identity column attributes behave like other defaults in that when an insert statement does not specify a value for the column, Splice Machine automatically provides the value. However, the value is not a constant; Splice Machine automatically increments the default value at insertion time.

The <span class="CodeFont">IDENTITY</span> keyword can only be specified if the data type associated with the column is one of the following exact integer types.

-   <span class="CodeFont">[SMALLINT](../DataTypes/SmallInt.html)</span>
-   <span class="CodeFont">[INT](../DataTypes/Integer.html)</span>
-   <span class="CodeFont">[BIGINT](../DataTypes/BigInt.html)</span>

By default, the initial value of an identity column is 1, and the amount of the increment is 1. You can specify any positive integer value for both the initial value and the interval amount when you define the column with the key words START WITH and INCREMENT BY. Splice Machine increments the value with each insert. A value of 0 raises a statement exception.

The maximum and minimum values allowed in identity columns are determined by the data type of the column. Attempting to insert a value outside the range of values supported by the data type raises an exception. The following table shows the supported ranges.

| Data Type                              | Maximum Value                                                                                                 | Minimum Value                                                                                     |
|----------------------------------------|---------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------|
| <span class="CodeFont">SMALLINT</span> | <span class="CodeFont">32767</span> (<span class="ItalicFont">java.lang.Short.MAX\_VALUE</span>)              | <span class="CodeFont">-32768</span> (<span class="ItalicFont">java.lang.Short.MIN\_VALUE</span>) |
| <span class="CodeFont">INT</span>      | <span class="CodeFont">2147483647</span> (<span class="ItalicFont">java.lang.Integer.MAX\_VALUE</span>)       | -2147483648 (<span class="ItalicFont">java.lang.Integer.MIN\_VALUE</span>)                        |
| <span class="CodeFont">BIGINT</span>   | <span class="CodeFont">9223372036854775807</span> (<span class="ItalicFont">java.lang.Long.MAX\_VALUE</span>) | -9223372036854775808 (<span class="ItalicFont">java.lang.Long.MIN\_VALUE</span>)                  |

Automatically generated values in an identity column are unique. Use a primary key or unique constraint on a column to guarantee uniqueness. Creating an identity column <span class="ItalicFont">does not</span> create an index on the column.

The [IDENTITY\_VAL\_LOCAL](../BuiltInFcns/IdentityValLocal.html) function is a non-deterministic function that returns the most recently assigned value for an identity column.

<span class="autonumber"><span class="noteAutoNum">NOTE:  </span></span>Specify the schema, table, and column name using the same case as those names are stored in the system tables--that is, all upper case unless you used delimited identifiers when creating those database objects.

Using Generated Columns

Splice Machine keeps track of the last increment value for a column in a cache. It also stores the value of what the next increment value will be for the column on disk in the <span class="CodeFont">AUTOINCREMENTVALUE</span> column of the <span class="CodeFont">SYS.SYSCOLUMNS</span> system table. Rolling back a transaction does not undo this value, and thus rolled-back transactions can leave "gaps" in the values automatically inserted into an identity column. Splice Machine behaves this way to avoid locking a row in <span class="CodeFont">SYS.SYSCOLUMNS</span> for the duration of a transaction and keeping concurrency high.

When an insert happens within a triggered-SQL-statement, the value inserted by the triggered-SQL-statement into the identity column is available from <span class="ItalicFont">ConnectionInfo</span> only within the trigger code. The trigger code is also able to see the value inserted by the statement that caused the trigger to fire. However, the statement that caused the trigger to fire is not able to see the value inserted by the triggered-SQL-statement into the identity column. Likewise, triggers can be nested (or recursive).

An SQL statement can cause trigger T1 to fire. T1 in turn executes an SQL statement that causes trigger T2 to fire. If both T1 and T2 insert rows into a table that cause Splice Machine to insert into an identity column, trigger T1 cannot see the value caused by T2's insert, but T2 can see the value caused by T1's insert. Each nesting level can see increment values generated by itself and previous nesting levels, all the way to the top-level SQL statement that initiated the recursive triggers. You can only have 16 levels of trigger recursion.

Examples

``` Example
create table greetings
  (i int generated by default
    as identity (START WITH 2, INCREMENT BY 1),
  ch char(50));
 -- specify value "1":
insert into greetings values (1, 'hi');
 -- use generated default
insert into greetings values (DEFAULT, 'salut');
 -- use generated default
insert into greetings(ch) values ('bonjour’);
drop table if exists words;

splice> CREATE TABLE WORDS(WORD VARCHAR(20), UWORD GENERATED ALWAYS AS (UPPER(WORD)));
0 rows inserted/updated/deleted
splice> CREATE INDEX IDX_UWORD ON WORDS(UWORD);
0 rows inserted/updated/deleted
splice> INSERT INTO WORDS(WORD) VALUES 'chocolate', 'Coca-Cola', 'hamburger', 'carrot';
4 rows inserted/updated/deleted
splice> select * from words;
WORD                |UWORD
--------------------------------------------------------------------------------
chocolate           |CHOCOLATE
Coca-Cola           |COCA-COLA
hamburger           |HAMBURGER
carrot              |CARROT

4 rows selected
splice> select upper(word) from words;
1
--------------------------------------------------------------------------------
CHOCOLATE
COCA-COLA
HAMBURGER
CARROT

4 rows selected
splice> drop table if exists t;
0 rows inserted/updated/deleted
WARNING 42Y55: 'DROP TABLE' cannot be performed on 'T' because it does not exist.
splice> CREATE TABLE T(COL1 INT, COL2 INT, COL3 GENERATED ALWAYS AS (COL1+COL2));
0 rows inserted/updated/deleted
splice> INSERT INTO T (COL1, COL2) VALUES (1,2), (3,4), (5,6);
3 rows inserted/updated/deleted
splice> select * from t;
COL1       |COL2       |COL3
--------------------------------------------------------------------------------
1          |2          |3
3          |4          |7
5          |6          |11

3 rows selected
splice> UPDATE T SET COL2 = 100 WHERE COL1 = 1;
1 row inserted/updated/deleted
splice> select * from t;
COL1       |COL2       |COL3
--------------------------------------------------------------------------------
1          |100        |101
3          |4          |7
5          |6          |11

3 rows selected
```

 


